//
// EvoLudo Project
//
// Copyright 2010-2025 Christoph Hauert
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// For publications in any form, you are kindly requested to attribute the
// author and project as follows:
//
//	Hauert, Christoph (<year>) EvoLudo Project, https://www.evoludo.org
//			(doi: 10.5281/zenodo.14591549 [, <version>])
//
//	<year>:    year of release (or download), and
//	<version>: optional version number (as reported in output header
//			or GUI console) to simplify replication of reported results.
//
// The formatting may be adjusted to comply with publisher requirements.
//

package org.evoludo.simulator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.evoludo.math.MersenneTwister;
import org.evoludo.math.RNGDistribution;
import org.evoludo.simulator.geometries.AbstractGeometry;
import org.evoludo.simulator.models.ChangeListener;
import org.evoludo.simulator.models.ChangeListener.PendingAction;
import org.evoludo.simulator.models.IBSPopulation;
import org.evoludo.simulator.models.LifecycleListener;
import org.evoludo.simulator.models.Model;
import org.evoludo.simulator.models.ModelType;
import org.evoludo.simulator.models.PDE;
import org.evoludo.simulator.models.PDESupervisor;
import org.evoludo.simulator.models.RunListener;
import org.evoludo.simulator.models.SampleListener;
import org.evoludo.simulator.modules.ATBT;
import org.evoludo.simulator.modules.CDL;
import org.evoludo.simulator.modules.CDLP;
import org.evoludo.simulator.modules.CDLPQ;
import org.evoludo.simulator.modules.CLabour;
import org.evoludo.simulator.modules.CSD;
import org.evoludo.simulator.modules.Centipede;
import org.evoludo.simulator.modules.DemesTBT;
import org.evoludo.simulator.modules.EcoPGG;
import org.evoludo.simulator.modules.LV;
import org.evoludo.simulator.modules.Module;
import org.evoludo.simulator.modules.Moran;
import org.evoludo.simulator.modules.NetGames;
import org.evoludo.simulator.modules.RSP;
import org.evoludo.simulator.modules.SIR;
import org.evoludo.simulator.modules.TBT;
import org.evoludo.simulator.views.HasPhase2D;
import org.evoludo.simulator.views.HasPop2D;
import org.evoludo.simulator.views.HasPop3D;
import org.evoludo.simulator.views.HasS3;
import org.evoludo.util.CLOCategory;
import org.evoludo.util.CLODelegate;
import org.evoludo.util.CLOProvider;
import org.evoludo.util.CLOption;
import org.evoludo.util.Plist;

/**
 * Interface with the outside world. Deals with command line options, help,
 * encoding/restoring state, logging, printing of result, etc. GWT/JRE neutral
 * abstract implementation of interface between EvoLudo core and GUI interface.
 * JRE specific code relegated to {@link org.evoludo.simulator.EvoLudoJRE
 * EvoLudoJRE} and GWT specific code to
 * {@link org.evoludo.simulator.EvoLudoGWT EvoLudoGWT}. Two distinct
 * implementations are required e.g. because of significant differences in
 * input/output routines.
 * 
 * @author Christoph Hauert
 */
public abstract class EvoLudo
		implements CLOProvider, MersenneTwister.Chronometer {

	/**
	 * The interface to execute commands in a manner that is agnostic to the
	 * implementation details regarding GWT or JRE environments.
	 */
	public interface Directive {

		/**
		 * The command to execute.
		 */
		public void execute();
	}

	/**
	 * Create an instance of the EvoLudo controller. EvoLudo manages different
	 * module/model implementations and the connection between simulations/numerical
	 * calculations and the GUI interface as well as the execution environment. This
	 * includes logging (verbosity and output channels), restoring previously saved
	 * engine states as well saving the current state of the engine, export its data
	 * or graphical snapshots.
	 */
	protected EvoLudo() {
		logger = Logger.getLogger(EvoLudo.class.getName() + "-" + ID);
	}

	/**
	 * The flag to indicate whether EvoLudo is running in a web browser (or ePub)
	 * using javascript generated by GWT or in the java JRE. Special characters in
	 * strings can result in headaches when running in an ePub (or, worse still, in
	 * XHTML pages).
	 * <p>
	 * <code>true</code> when running as GWT application; <code>false</code> for JRE
	 * applications.
	 */
	static boolean isGWT = false;

	/**
	 * The loggers of each EvoLudo lab instance need to have unique names to keep
	 * the logs separate. Use <code>IDcounter</code> to generate unique
	 * <code>ID</code>'s.
	 */
	private static int IDcounter = 0;

	/**
	 * Unique <code>ID</code> of EvoLudo instance.
	 * 
	 * @see #IDcounter
	 */
	public final int ID = IDcounter++;

	/**
	 * The logger for keeping track of and reporting events and issues.
	 */
	protected Logger logger;

	/**
	 * Utility method to log progress of simulations. For implementation details see
	 * {@link org.evoludo.simulator.EvoLudoJRE EvoLudoJRE} and
	 * {@link org.evoludo.simulator.EvoLudoGWT EvoLudoGWT}
	 *
	 * @param msg progress message
	 */
	public abstract void logProgress(String msg);

	/**
	 * Convenience method to log messages of simulations.
	 *
	 * @param msg information message
	 */
	public void logMessage(String msg) {
		logger.info(msg);
	}

	/**
	 * Convenience method to log warnings of simulations.
	 *
	 * @param msg warning message
	 */
	public void logWarning(String msg) {
		logger.warning(msg);
	}

	/**
	 * Convenience method to log errors of simulations.
	 *
	 * @param msg error message
	 */
	public void logError(String msg) {
		logger.severe(msg);
	}

	/**
	 * The shared random number generator to ensure reproducibility of results.
	 * 
	 * @see #getRNG()
	 */
	protected RNGDistribution rng = new RNGDistribution.Uniform();

	/**
	 * Get the shared random number generator to ensure the reproducibility of
	 * results. This is the only RNG that <strong>MUST</strong> be used for all
	 * calculation, i.e. must be shared with all models including distributions
	 * (e.g. for mutations, migration...)
	 * <p>
	 * <strong>Important:</strong>
	 * <ol>
	 * <li><em>Must</em> be used for any random numbers related to the modelling.
	 * <li>Must <em>not</em> be used for anything else, e.g. shared with layout
	 * procedures for networks (although it may be desirable to set a seed for the
	 * layout routines in a consistent manner if one was set for the simulations, to
	 * also ensure visual reproducibility).
	 * <li>If the number of random numbers drawn changes, any corresponding test
	 * fails almost certainly. Tests pass only if the results are identical.
	 * </ol>
	 *
	 * @return the one and only random number generator for modelling
	 * 
	 * @see RNGDistribution
	 */
	public RNGDistribution getRNG() {
		return rng;
	}

	/**
	 * The lookup table for all available modules.
	 */
	protected HashMap<String, Module<?>> modules = new HashMap<>();

	/**
	 * Generate 2D network. This is the factory method to provide different
	 * implementations for GWT and JRE. More specifically, the layouting process in
	 * GWT uses scheduling (asynchronous execution) to prevent the GUI from
	 * stalling, while JRE implementations take advantage of multiple threads for
	 * significantly faster execution due to parallelization.
	 * 
	 * @param geometry the geometry backing the 2D network
	 * @return new instance of a 2D network
	 */
	public abstract Network2D createNetwork2D(AbstractGeometry geometry);

	/**
	 * Generate 3D network. This is the factory method to provide different
	 * implementations for GWT and JRE. More specifically, the layouting process in
	 * GWT uses scheduling (asynchronous execution) to prevent the GUI from
	 * stalling, while JRE implementations take advantage of multiple threads for
	 * significantly faster execution due to parallelization.
	 * <p>
	 * <strong>Note:</strong> The {@code java3d} package is obsolete. At present no
	 * 3D implementation for java exists.
	 * 
	 * @param geometry the geometry backing the 3D network
	 * @return new instance of a 3D network
	 */
	public abstract Network3D createNetwork3D(AbstractGeometry geometry);

	/**
	 * The active model
	 */
	protected Model activeModel;

	/**
	 * Set model type and loads the corresponding frameworks for individual based
	 * simulations or numerical integration of ODE/SDE/PDE models. Notifies all
	 * registered {@link LifecycleListener}s of any changes.
	 *
	 * @param type the type of {@link Model} to load
	 */
	public void loadModel(ModelType type) {
		lifecycleController.loadModel(type);
	}

	/**
	 * Get the active model.
	 * 
	 * @return the active model
	 */
	public Model getModel() {
		return activeModel;
	}

	/**
	 * The flag to indicate whether a reset of the active model has been requested.
	 * This is necessary after certain parameter changes. For example, changing the
	 * population size (see {@link IBSPopulation#nPopulation}) requires a reset to
	 * (re)generate population geometries and initialize traits.
	 */
	protected boolean resetRequested = true;

	/**
	 * Request reset the active model, e.g. after change of parameters.
	 * 
	 * @param reset <code>true</code> if reset is requested
	 */
	public void requiresReset(boolean reset) {
		resetRequested |= reset;
	}

	/**
	 * Request full reparsing of the command line options. This is necessary if the
	 * command line options have changed in a fundamental way, for example if the
	 * number of traits in a module has changed.
	 */
	public void requestParseCLO() {
		cloController.requestParseCLO();
	}

	/**
	 * Controller for command line option parsing.
	 */
	protected final CLOController cloController = new CLOController(this);

	public final CLOption cloSeed = cloController.cloSeed;
	public final CLOption cloRun = cloController.cloRun;

	/**
	 * Controller for lifecycle listeners.
	 */
	protected final LifecycleController lifecycleController = new LifecycleController(this);

	/**
	 * Controller for run listeners.
	 */
	protected final RunController runController = new RunController(this);

	/**
	 * Add a lifecycle listener to the list of listeners that get notified when the
	 * model reaches lifecycle milestones.
	 * 
	 * @param newListener the new lifecycle listener
	 */
	public void addLifecycleListener(LifecycleListener newListener) {
		lifecycleController.addListener(newListener);
	}

	/**
	 * Remove the lifecycle listener from the list of listeners that get notified
	 * when the model reaches lifecycle milestones.
	 * 
	 * @param obsoleteListener the listener to remove from list of lifecycle
	 *                         listeners
	 */
	public void removeLifecycleListener(LifecycleListener obsoleteListener) {
		lifecycleController.removeListener(obsoleteListener);
	}

	/**
	 * Add a run listener to the list of listeners that get notified about model run
	 * state changes.
	 * 
	 * @param newListener the new run listener
	 */
	public void addRunListener(RunListener newListener) {
		runController.addListener(newListener);
	}

	/**
	 * Remove the run listener from the list of listeners that get notified when the
	 * model run state changes.
	 * 
	 * @param obsoleteListener the listener to remove from list of run listeners
	 */
	public void removeRunListener(RunListener obsoleteListener) {
		runController.removeListener(obsoleteListener);
	}

	/**
	 * List of change listeners that get notified when the model changes.
	 */
	protected List<ChangeListener> changeListeners = new ArrayList<>();

	/**
	 * Add a change listener to the list of listeners that get notified when the
	 * model changes.
	 * 
	 * @param newListener the new change listener
	 */
	public void addChangeListener(ChangeListener newListener) {
		if (!changeListeners.contains(newListener))
			changeListeners.add(0, newListener);
	}

	/**
	 * Remove the change listener from the list of listeners that get notified when
	 * the model changes.
	 * 
	 * @param obsoleteListener the listener to remove from the list of change
	 *                         listeners
	 */
	public void removeChangeListener(ChangeListener obsoleteListener) {
		changeListeners.remove(obsoleteListener);
	}

	/**
	 * List of change listeners that get notified when the model changes.
	 */
	protected List<SampleListener> sampleListeners = new ArrayList<>();

	/**
	 * Add a change listener to the list of listeners that get notified when the
	 * model changes.
	 * 
	 * @param newListener the new change listener
	 */
	public void addSampleListener(SampleListener newListener) {
		if (!sampleListeners.contains(newListener))
			sampleListeners.add(0, newListener);
	}

	/**
	 * Remove the change listener from the list of listeners that get notified when
	 * the model changes.
	 * 
	 * @param obsoleteListener the listener to remove from the list of change
	 *                         listeners
	 */
	public void removeSampleListener(SampleListener obsoleteListener) {
		sampleListeners.remove(obsoleteListener);
	}

	/**
	 * Unload model framework. Notifies all registered
	 * {@link LifecycleListener}s.
	 */
	public void unloadModel() {
		lifecycleController.unloadModel();
	}

	/**
	 * Unload model framework and, if requested, notifies all registered
	 * {@link LifecycleListener}s.
	 * 
	 * @param quiet set to {@code true} to skip notifying listeners
	 */
	public void unloadModel(boolean quiet) {
		lifecycleController.unloadModel(quiet);
	}

	/**
	 * Check consistency of parameters in all populations.
	 * <p>
	 * <strong>Note:</strong> in multi-species interactions optimizations seem
	 * sensible only if all populations involved approve of them.
	 *
	 * @return <code>true</code> if reset is required
	 */
	public final boolean modelCheck() {
		// special case: if --generation 0 model should not run regardless of
		// whether --run option was provided.
		if (Math.abs(activeModel.getTimeStop()) < 1e-8)
			setSuspended(false);
		// check module first; model may contact module
		boolean doReset = false;
		for (Module<?> mod : activeModule.getSpecies())
			doReset |= mod.check();
		ModelType type = activeModel.getType();
		doReset |= activeModel.check();
		ModelType newtype = activeModel.getType();
		if (newtype != type) {
			// model type changed; update model type in clo and parse again
			String[] splitclo = getSplitCLO();
			int idx = 0;
			for (String o : splitclo) {
				if (o.startsWith("model")) {
					splitclo[idx] = "model " + newtype.getKey();
					break;
				}
				idx++;
			}
			parseCLO(splitclo);
			return modelCheck();
		}
		return doReset;
	}

	/**
	 * Reset all populations and notify all listeners.
	 */
	public final void modelReset() {
		runController.modelReset();
	}

	/**
	 * Reset all populations and notify all listeners if requested.
	 * <p>
	 * <strong>Note:</strong> if {@code quiet == true} statistics are preserved.
	 * 
	 * @param quiet set to {@code true} to skip notifying listeners
	 */
	public final void modelReset(boolean quiet) {
		runController.modelReset(quiet);
	}

	/**
	 * Initialize all populations and notify all listeners.
	 */
	public final void modelInit() {
		runController.modelInit();
	}

	/**
	 * Initialize all populations and notify all listeners if requested. In contrast
	 * to {@link #modelReset(boolean)} this method does not re-generate the
	 * population structures.
	 * 
	 * @param quiet set to {@code true} to skip notifying listeners
	 */
	public final void modelInit(boolean quiet) {
		runController.modelInit(quiet);
	}

	/**
	 * Relax model by {@code timeRelax} steps and notify all listeners when done. If
	 * model converged during relaxation notify listeners that model has stopped.
	 *
	 * @return <code>true</code> if converged
	 * 
	 * @see Model#relax()
	 */
	public final boolean modelRelax() {
		return runController.modelRelax();
	}

	/**
	 * Relax model by {@code timeRelax} steps and notify all listeners if requested.
	 *
	 * @param quiet set to {@code true} to skip notifying listeners
	 * 
	 * @return <code>true</code> if converged
	 * 
	 * @see Model#relax()
	 */
	public final boolean modelRelax(boolean quiet) {
		return runController.modelRelax(quiet);
	}

	/**
	 * Advance model by one step (<code>reportFreq</code> updates) and notify
	 * all listeners.
	 *
	 * @return <code>true</code> if not converged, i.e. if <code>modelNext()</code>
	 *         can be called again.
	 */
	public final boolean modelNext() {
		return runController.modelNext();
	}

	/**
	 * Called after the calculations of the next state of the model have finished.
	 * For GWT this method serves as a callback for the asynchronous model
	 * computations. For JRE this runs in a separate thread from the GUI and
	 * {@link #modelNext()} directly calls this.
	 *
	 * @param cont <code>false</code> if converged or halting time reached
	 * @return <code>true</code> if not converged, i.e. if <code>modelNext()</code>
	 *         can be called again.
	 */
	public final boolean modelNextDone(boolean cont) {
		return runController.modelNextDone(cont);
	}

	/**
	 * Called after parameters have changed. Checks new settings and resets
	 * population(s) (and/or GUI) if necessary.
	 *
	 * @return <code>true</code> if reset was necessary
	 */
	public boolean paramsDidChange() {
		if (resetRequested || modelCheck()) {
			modelReset();
			return true;
		}
		activeModel.update();
		fireSettingsChanged();
		return false;
	}

	/**
	 * The command line options (raw string provided in URL, HTML tag, TextArea or
	 * command line)
	 */
	protected String clo = "";

	/**
	 * Get the raw command line options, as provided in URL, HTML tag, settings
	 * TextArea or command line.
	 * 
	 * @return command line options
	 */
	public String getCLO() {
		return cloController.getCLO();
	}

	/**
	 * Get the command line options split into an array with option names followed
	 * by their arguments (if applicable).
	 * 
	 * @return array command line options and arguments
	 */
	public String[] getSplitCLO() {
		return cloController.getSplitCLO();
	}

	/**
	 * Set the raw command line options, as shown e.g. in the settings TextArea.
	 * 
	 * @param clo the new command line option string
	 */
	public void setCLO(String clo) {
		cloController.setCLO(clo);
	}

	/**
	 * Minimum delay between subsequent updates for speed slider
	 * {@link org.evoludo.ui.Slider}
	 */
	public static final double DELAY_MIN = 1.0;

	/**
	 * Maximum delay between subsequent updates for speed slider
	 * {@link org.evoludo.ui.Slider}
	 */
	public static final double DELAY_MAX = 10000.0;

	/**
	 * Initial delay between subsequent updates for speed slider
	 * {@link org.evoludo.ui.Slider}
	 */
	public static final double DELAY_INIT = 100.0;
	/**
	 * Delay decrement for speed slider {@link org.evoludo.ui.Slider}
	 */
	protected static final double DELAY_INCR = 1.2;

	/**
	 * The flag to indicate whether running of the model is suspended. For example
	 * while parameters are being applied. If the changes do not require a reset of
	 * the model the calculations are resumed after new parameters are applied. Also
	 * used when command line options are set to immediately start running after
	 * loading (see {@link CLOController#cloRun}).
	 */
	protected boolean isSuspended = false;

	/**
	 * Check whether the current model is suspended.
	 * 
	 * @return <code>true</code> if model is suspended
	 */
	public boolean isSuspended() {
		return isSuspended;
	}

	/**
	 * Set the flag indicating whether the model is suspended. A suspended model
	 * resumes execution as soon as possible. For example after a new set parameters
	 * has been checked.
	 *
	 * @param suspend <code>true</code> to indicate that model is suspended.
	 */
	public void setSuspended(boolean suspend) {
		isSuspended = suspend;
		if (isSuspended)
			isRunning = false;
	}

	/**
	 * Set delay between subsequent updates.
	 *
	 * @param delay in milliseconds
	 */
	public void setDelay(int delay) {
		runController.setDelay(delay);
	}

	/**
	 * Get delay between subsequent updates.
	 *
	 * @return the delay in milliseconds
	 */
	public int getDelay() {
		return runController.getDelay();
	}

	/**
	 * Increase delay between subsequent updates by fixed factor.
	 */
	public void increaseDelay() {
		runController.increaseDelay();
	}

	/**
	 * Decrease delay between subsequent updates by fixed factor.
	 */
	public void decreaseDelay() {
		runController.decreaseDelay();
	}

	/**
	 * Load new module with key <code>newModuleKey</code>. If necessary first
	 * unload current module. Upon successful loading of a new module the method
	 * returns {@code true}. If <code>newModuleKey</code> is not found but an active
	 * module is present, the active module is kept and the method returns
	 * {@code true}. Without an active module the method returns {@code false}.
	 *
	 * @param newModuleKey the key of the module to load
	 * @return false if <code>newModuleKey</code> not found and no active module
	 *         present; true otherwise
	 */
	public boolean loadModule(String newModuleKey) {
		return lifecycleController.loadModule(newModuleKey);
	}

	/**
	 * Unload current module to free up resources.
	 * 
	 * <h3>Implementation note:</h3>
	 * Called from {@link loadModule} to first unload the active module or triggered
	 * by GWT's {@link org.evoludo.EvoLudoWeb#onUnload()}, i.e. when unloading the
	 * GWT application.
	 */
	public void unloadModule() {
		lifecycleController.unloadModule();
	}

	/**
	 * The active module.
	 */
	protected Module<?> activeModule;

	/**
	 * Gets the active {@link Module}.
	 * 
	 * @return the active module
	 */
	public Module<?> getModule() {
		return activeModule;
	}

	/**
	 * Access the module command line option.
	 * 
	 * @return the module option
	 */
	public CLOption getCloModuleOption() {
		return cloController.cloModule;
	}

	/**
	 * Add <code>module</code> to lookup table of modules using the module's key. If
	 * a GUI is present, add GUI as a listener of <code>module</code> to get
	 * notified about state changes.
	 *
	 * @param module the module to add to lookup table
	 */
	public void addModule(Module<?> module) {
		String key = module.getKey();
		modules.put(key, module);
		cloController.addModuleKey(key, module.getTitle());
	}

	/**
	 * Execute <code>directive</code> in JRE or GWT environments.
	 *
	 * @param directive the directive to execute in appropriate GWT or JRE manners
	 */
	public abstract void execute(Directive directive);

	/**
	 * The flag to indicate whether the active model is running.
	 */
	protected boolean isRunning = false;

	/**
	 * Check if the active model is running.
	 * 
	 * @return <code>true</code> if model is running
	 */
	public boolean isRunning() {
		return isRunning;
	}

	/**
	 * Notification from GUI that layout process has finished. Opportunity for
	 * taking snapshots.
	 */
	public void layoutComplete() {
		run();
	}

	/**
	 * Requests halting of a running {@link Model} on the next opportunity.
	 */
	public void stop() {
		runController.stop();
	}

	/**
	 * Start the EvoLudo model and calculate the dynamics one step at a time.
	 */
	public abstract void run();

	/**
	 * Advances the EvoLudo model by a single step. Called when pressing the 'Step'
	 * button, the 'n' or 'right-arrow' key.
	 */
	public abstract void next();

	/**
	 * Start or stop EvoLudo model. If model is running wait until next update
	 * is completed to prevent unexpected side effects.
	 */
	public void startStop() {
		runController.startStop();
	}

	/**
	 * Flag to indicate if a backstep is in progress.
	 */
	// maintained in RunController

	/**
	 * Attempts to backtrack a single step of the EvoLudo model. Called when
	 * pressing the 'Prev' button, the 'p' or 'left-arrow' key.
	 */
	public void prev() {
		runController.prev();
	}

	/**
	 * Advances the EvoLudo model by a single debugging step. Called when pressing
	 * the 'Debug' button or 'D' key.
	 */
	public void debug() {
		runController.debug();
	}

	/**
	 * Run simulation. Currently only implemented by EvoLudoJRE. Returns control to
	 * caller only if the arguments in {@code clo} do not match requirements for
	 * running a simulation.
	 * 
	 * @see #setCLO(String)
	 * @see org.evoludo.simulator.EvoLudoJRE#simulation()
	 */
	public void simulation() {
	}

	/**
	 * The action that is pending (if any).
	 */
	protected PendingAction pendingAction = PendingAction.NONE;

	/**
	 * Requests a {@link PendingAction} to be processed on the next opportunity. If
	 * model is not running the action is processed immediately.
	 * 
	 * @param action the action requested
	 */
	public synchronized void requestAction(PendingAction action) {
		runController.requestAction(action);
	}

	/**
	 * Requests a {@link PendingAction} to be processed on the next opportunity. If
	 * model is not running or {@code now} is set to {@code true} the action is
	 * processed immediately.
	 * 
	 * @param action the action requested
	 * @param now    <code>true</code> to processes action immediately
	 */
	public synchronized void requestAction(PendingAction action, boolean now) {
		runController.requestAction(action, now);
	}

	/**
	 * Called whenever a new module has finished loading. Notifies all registered
	 * {@link LifecycleListener}s.
	 */
	public synchronized void fireModuleLoaded() {
		pendingAction = PendingAction.NONE;
		lifecycleController.fireModuleLoaded();
	}

	/**
	 * Called whenever the current module has finished unloading. Notifies all
	 * registered {@link LifecycleListener}s.
	 */
	public synchronized void fireModuleUnloaded() {
		lifecycleController.fireModuleUnloaded();
		activeModule = null;
	}

	/**
	 * Called after the state of the model has been restored either through
	 * drag'n'drop with the GWT GUI or through the <code>--restore</code> command
	 * line argument. Notifies all registered {@link LifecycleListener}s.
	 *
	 * @see #restoreFromFile()
	 * @see #restoreState(Plist)
	 */
	public synchronized void fireModuleRestored() {
		lifecycleController.fireModuleRestored();
	}

	/**
	 * Called whenever a new model has finished loading. Notifies all registered
	 * {@link LifecycleListener}s.
	 */
	public synchronized void fireModelLoaded() {
		pendingAction = PendingAction.NONE;
		lifecycleController.fireModelLoaded();
	}

	/**
	 * Called whenever a new model has finished loading. Notifies all registered
	 * {@link LifecycleListener}s.
	 */
	public synchronized void fireModelUnloaded() {
		pendingAction = PendingAction.NONE;
		lifecycleController.fireModelUnloaded();
	}

	/**
	 * Called whenever the model starts its calculations. Fires only when starting
	 * to run. Notifies all registered {@link RunListener}s.
	 */
	public synchronized void fireModelRunning() {
		runController.fireModelRunning();
	}

	/**
	 * Called whenever the state of the model has changed. For example, to
	 * trigger the update of the state displayed in the GUI. Processes pending
	 * actions and notifies all registered {@code RunListener}s.
	 * 
	 * @see RunListener
	 * @see PendingAction
	 */
	public synchronized void fireModelChanged() {
		switch (activeModel.getMode()) {
			default:
			case STATISTICS_UPDATE:
			case DYNAMICS:
				processPendingAction();
				break;
			case STATISTICS_SAMPLE:
				break;
		}
	}

	/**
	 * Helper to process pending actions. Delegates to {@link RunController} but
	 * exposed for subclasses that need to hook additional behavior.
	 */
	void processPendingAction() {
		runController.processPendingAction();
	}

	/**
	 * Called after the population has reached an absorbing state (or has converged
	 * to an equilibrium state). Notifies all registered
	 * {@link RunListener}s.
	 * 
	 * @param success <code>true</code> if sample completed successfully
	 * @return <code>true</code> to continue with next sample
	 * 
	 * @see SampleListener
	 */
	public synchronized boolean fireModelSample(boolean success) {
		// check if new sample completed
		activeModel.readStatisticsSample();
		for (SampleListener i : sampleListeners)
			i.modelSample(success);
		if (activeModel.getNSamples() == activeModel.getNStatisticsSamples()) {
			// all samples completed - fire stop
			fireModelStopped();
			return false;
		}
		return isRunning;
	}

	/**
	 * Called whenever the settings of the model have changed. For example, to
	 * trigger the range of values or markers in the GUI. Notifies all registered
	 * {@link RunListener}s.
	 * 
	 * @see RunListener
	 */
	public synchronized void fireSettingsChanged() {
		runController.fireSettingsChanged();
	}

	/**
	 * Called after the model has been re-initialized. Notifies all registered
	 * {@link RunListener}s.
	 */
	public synchronized void fireModelInit() {
		runController.fireModelInit();
	}

	/**
	 * Called after the model has been reset. Notifies all registered
	 * {@link RunListener}s.
	 */
	public synchronized void fireModelReset() {
		runController.fireModelReset();
	}

	/**
	 * Called after the model completed its relaxation. Notifies all registered
	 * {@link RunListener}s.
	 */
	public synchronized void fireModelRelaxed() {
		runController.fireModelRelaxed();
	}

	/**
	 * Called after the population has reached an absorbing state (or has converged
	 * to an equilibrium state). Notifies all registered
	 * {@link RunListener}s.
	 */
	public synchronized void fireModelStopped() {
		runController.fireModelStopped();
	}

	/**
	 * <strong>Note:</strong> Instead of sharing logging system, EvoLudo could
	 * implement helper routines for logging notifications. However, when logging
	 * notifications with a severity of {@link Level#WARNING} or higher the default
	 * logging message includes the name of the calling routine and hence would
	 * always refer to the (unhelpful) helper routines.
	 *
	 * @return logger of this EvoLudo controller
	 */
	public Logger getLogger() {
		return logger;
	}

	/**
	 * Hire supervisor for managing PDE calculations. This is the factory method
	 * provide different implementations For GWT and JRE. More specifically, GWT
	 * uses asynchronous execution to prevent the GUI from stalling, while JRE
	 * implementations take advantage of multiple threads for significantly faster
	 * execution due to parallelization.
	 *
	 * @param charge the PDE model to supervise
	 * @return supervisor for coordinating PDE calculations
	 * 
	 * @see org.evoludo.simulator.EvoLudoGWT#hirePDESupervisor(org.evoludo.simulator.models.PDE)
	 *      EvoLudoGWT#hirePDESupervisor(PDERD)
	 * @see org.evoludo.simulator.EvoLudoJRE#hirePDESupervisor(org.evoludo.simulator.models.PDE)
	 *      EvoLudoJRE#hirePDESupervisor(PDERD)
	 * @see org.evoludo.simulator.models.PDESupervisor
	 * @see org.evoludo.simulator.models.PDESupervisorGWT
	 * @see org.evoludo.simulator.models.PDESupervisorJRE
	 */
	public abstract PDESupervisor hirePDESupervisor(PDE charge);

	/**
	 * The copyright string.
	 */
	public static final String COPYRIGHT = "Â© Christoph Hauert";

	/**
	 * Responsible for encoding/restoring state and handling version reporting.
	 */
	protected final StateEncoder stateEncoder = new StateEncoder(this);

	/**
	 * Return version string of current model. Version must include reference to git
	 * commit to ensure reproducibility of results.
	 *
	 * @return the version string
	 */
	public String getVersion() {
		return stateEncoder.getVersion();
	}

	/**
	 * Get version of JRE (if not running in browser).
	 * 
	 * @return the java version string
	 */
	public String getJavaVersion() {
		return null;
	}

	/**
	 * Gets current git version of code base.
	 * 
	 * @return the git version string
	 */
	public abstract String getGit();

	/**
	 * Gets the compilation date of the current git version.
	 * 
	 * @return the git compilation date as a string
	 */
	public abstract String getGitDate();

	/**
	 * timeout for layout process of snapshots in msec.
	 */
	protected int snapLayoutTimeout = -1;

	/**
	 * Gets the timeout for the layout process of snapshots in msec.
	 * 
	 * @return timeout in msec
	 */
	public int getSnapLayoutTimeout() {
		return snapLayoutTimeout;
	}

	/**
	 * Write header of report to <code>output</code> (currently JRE only). The
	 * information should include items like the version of the EvoLudo code, the
	 * current date and the string of command line options for reproducibility.
	 */
	public void writeHeader() {
	}

	/**
	 * Concluding words for report (currently JRE only).
	 */
	public void writeFooter() {
	}

	/**
	 * Export the current state of the engine using the appropriate means available
	 * in the current environment (GWT/JRE).
	 * 
	 * @see org.evoludo.simulator.EvoLudoGWT#exportState()
	 * @see org.evoludo.simulator.EvoLudoJRE#exportState()
	 */
	public abstract void exportState();

	/**
	 * Encode current state of EvoLudo model as XML string (plist format).
	 *
	 * @return encoded state
	 */
	public String encodeState() {
		return stateEncoder.encodeState();
	}

	/**
	 * Restore state of EvoLudo model from saved plist, which encodes engine state.
	 * 
	 * @return {@code true} on successfully restoring state
	 * @see #encodeState()
	 */
	public abstract boolean restoreFromFile();

	/**
	 * Restore state of EvoLudo model from pre-processed plist, which encodes engine
	 * state (see {@link #encodeState()}).
	 * <p>
	 * <strong>Note:</strong> the appropriate model must already have been loaded
	 * and the command line arguments specified with the key <code>CLO</code> in the
	 * <code>plist</code> must also have been processed already.
	 * </p>
	 * <p>
	 * In JRE the options in <code>plist</code> are merged with any other command
	 * line arguments (albeit the ones in <code>plist</code> have priority to
	 * minimize the chance of complications). In GWT
	 * <code>restoreState(Plist)</code> is overridden to first deal with the command
	 * line arguments.
	 * </p>
	 *
	 * @param plist the lookup table with key value pairs
	 * @return {@code true} on successfully restoring state
	 */
	public boolean restoreState(Plist plist) {
		return stateEncoder.restoreState(plist);
	}

	/**
	 * Register <code>clo</code> as a provider of command line options. Initialize
	 * command line parser if necessary.
	 *
	 * @param provider the option provider to add
	 */
	public void addCLOProvider(CLOProvider provider) {
		cloController.addCLOProvider(provider);
	}

	/**
	 * Unregister <code>clo</code> as a provider of command line options.
	 *
	 * @param provider the option provider to remove
	 */
	public void removeCLOProvider(CLOProvider provider) {
		cloController.removeCLOProvider(provider);
	}

	/**
	 * Pre-process array of command line arguments. Some arguments need priority
	 * treatment. Examples include the options <code>--module</code>,
	 * <code>--verbose</code> or <code>--restore</code>.
	 * <dl>
	 * <dt>{@code --module}</dt>
	 * <dd>load module and remove option</dd>
	 * <dt>{@code --verbose}</dt>
	 * <dd>set verbosity level effective immediately. This ensures that issues when
	 * parsing the remaining command line options are already properly reported</dd>
	 * </dl>
	 *
	 * @param cloarray array of command line arguments
	 * @return pre-processed array of command line options
	 * 
	 * @see org.evoludo.simulator.EvoLudoJRE#preprocessCLO(String[])
	 *      EvoLudoJRE#preprocessCLO(String[])
	 * @see org.evoludo.simulator.EvoLudoGWT#preprocessCLO(String[])
	 *      EvoLudoGWT#preprocessCLO(String[])
	 */
	protected String[] preprocessCLO(String[] cloarray) {
		return cloController.preprocessCLO(cloarray);
	}

	/**
	 * Parse command line options.
	 *
	 * @return the number of issues that have occurred durin parsing
	 * 
	 * @see #parseCLO(String[])
	 */
	public int parseCLO() {
		return cloController.parseCLO();
	}

	/**
	 * Pre-process and parse array of command line arguments.
	 *
	 * @param cloarray string array of command line arguments
	 * @return the number of issues that have occurred durin parsing
	 * 
	 * @see #preprocessCLO(String[])
	 * @see CLOParser#parseCLO(String[])
	 */
	protected int parseCLO(String[] cloarray) {
		return cloController.parseCLO(cloarray);
	}

	/**
	 * Format, encode and output help on command line options.
	 * 
	 * @return the help string
	 */
	public String getCLOHelp() {
		return cloController.getCLOHelp();
	}

	/**
	 * Show help on command line options.
	 */
	public abstract void showHelp();

	/**
	 * {@inheritDoc}
	 * <p>
	 * <strong>Note:</strong> In contrast to other providers of command line
	 * options, the EvoLudo class delegates collection to the controller which
	 * maintains the shared parser.
	 */
	@Override
	public void collectCLO(CLOParser prsr) {
		cloController.collectCLO(prsr);
	}

	/**
	 * Get the type of color model for translating continuous traits into colors.
	 * 
	 * @return the type of color model
	 * 
	/**
	 * Report error and stop model execution, if running.
	 * <p>
	 * <strong>IMPORTANT:</strong> Does not return control to caller.
	 * 
	 * @param msg the error message
	 */
	public void fatal(String msg) {
		// stops any ongoing calculations as soon as possible
		pendingAction = PendingAction.STOP;
		if (isRunning) {
			// calling stop() doesn't work because PendingAction.STOP
			// is never processed; do it manually
			fireModelStopped();
			pendingAction = PendingAction.NONE;
		}
		logger.severe(msg);
		if (isGWT)
			throw new Error(msg);
	}

	/**
	 * Load all available modules. Specific modules are the responsibility of the
	 * caller.
	 */
	public void loadModules() {
		// load all available modules
		addModule(new Moran(this));
		addModule(new TBT(this));
		addModule(new ATBT(this));
		addModule(new DemesTBT(this));
		addModule(new RSP(this));
		addModule(new CDL(this));
		addModule(new CDLP(this));
		addModule(new CDLPQ(this));
		addModule(new Centipede(this));
		addModule(new EcoPGG(this));
		addModule(new CSD(this));
		addModule(new CLabour(this));
		addModule(new NetGames(this));
		addModule(new SIR(this));
		addModule(new LV(this));
	}
}
